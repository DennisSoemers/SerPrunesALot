#include "SerPrunesALotWindow.h"
#include "QDesktopWidget.h"
#include "QGridLayout.h"
#include "QIcon.h"
#include "QLabel.h"

#include "Logger.h"
#include "Move.h"

SerPrunesALotWindow::SerPrunesALotWindow(QWidget *parent)
	: QMainWindow(parent),
	boardButtons(), 
	highlightedButtons(), 
	currentGameState(), 
	selectedButton(nullptr),
	ui()
{
	// NOTE: hardcoding this means only board sizes up to 8x8 are supported
	char* COORDS_NUMBERS[] = { "1", "2", "3", "4", "5", "6", "7", "8" };
	char* COORDS_LETTERS[] = { "A", "B", "C", "D", "E", "F", "G", "H" };

	ui.setupUi(this);	// call the setup method that was automatically generated by the project creation wizard

	// other setup stuff
	setWindowTitle("Ser Prunes-A-Lot");
	setCentralWidget(new QWidget(this));

	// Place window in middle of screen
	QDesktopWidget* desktop = QApplication::desktop();

	int screenWidth = desktop->width();
	int screenHeight = desktop->height();

	int windowWidth = 800;
	int windowHeight = 750;

	resize(windowWidth, windowHeight);
	move(((screenWidth - windowWidth) / 2), ((screenHeight - windowHeight) / 2));

	/* TODO: set icon
	window.setWindowIcon(QIcon("file.png"));
	*/

	QGridLayout* gridLayout = new QGridLayout(this);
	gridLayout->setSpacing(0);

	// draw letters and numbers as ''coordinates'' for buttons
	for (int i = 1; i <= BOARD_HEIGHT; ++i)
	{
		QLabel* labelLeft = new QLabel(QString::fromLatin1(COORDS_NUMBERS[BOARD_HEIGHT - i]), this);
		labelLeft->setMinimumWidth(30);
		gridLayout->addWidget(labelLeft, i, 0);

		QLabel* labelRight = new QLabel(QString("     ").append(QString::fromLatin1(COORDS_NUMBERS[BOARD_HEIGHT - i])), this);
		labelRight->setMinimumWidth(30);
		gridLayout->addWidget(labelRight, i, BOARD_WIDTH + 1);
	}

	for (int i = 0; i < BOARD_WIDTH; ++i)
	{
		QLabel* labelTop = new QLabel(QString("     ").append(QString::fromLatin1(COORDS_LETTERS[i])), this);
		labelTop->setMinimumHeight(30);
		gridLayout->addWidget(labelTop, 0, i + 1);

		QLabel* labelBot = new QLabel(QString("       ").append(QString::fromLatin1(COORDS_LETTERS[i])), this);
		labelBot->setMinimumHeight(30);
		gridLayout->addWidget(labelBot, BOARD_HEIGHT + 1, i + 1);
	}

	// fill board with buttons
	boardButtons.reserve(BOARD_HEIGHT);

	for (int i = 0; i < BOARD_HEIGHT; ++i)
	{
		std::vector<GameBoardButton*> row;
		row.reserve(BOARD_WIDTH);

		for (int j = 0; j < BOARD_WIDTH; ++j)
		{
			GameBoardButton* button = new GameBoardButton(i, j, this);

			button->setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding));
			button->setToolTip(QString::fromLatin1(COORDS_LETTERS[j]).append(QString::fromLatin1(COORDS_NUMBERS[BOARD_HEIGHT - i - 1])));
			button->resetBackgroundColor();

			row.push_back(button);
			gridLayout->addWidget(button, i + 1, j + 1);

			connect(button, &GameBoardButton::clicked, button, &GameBoardButton::onClicked);
		}

		boardButtons.push_back(row);
	}

	centralWidget()->setLayout(gridLayout);

	initBoard();
}

SerPrunesALotWindow::~SerPrunesALotWindow()
{}

void SerPrunesALotWindow::buttonClicked(GameBoardButton* button)
{
	BoardLocation clickedLoc = BoardLocation(button->column, button->row);
	EPlayerColors::Type occupier = currentGameState.getOccupier(clickedLoc);
	EPlayerColors::Type currentPlayer = currentGameState.getCurrentPlayer();

	// TODO: check if currentPlayer is manually controlled and not an AI player

	if (occupier == currentPlayer)		// clicked a button that we have a knight on
	{
		selectedButton = button;

		// revert all currently highlighted buttons back to their normal color
		for (GameBoardButton* highlighted : highlightedButtons)
		{
			highlighted->resetBackgroundColor();
		}
		highlightedButtons.clear();

		// generatete moves possible from this location and highlight them
		std::vector<Move> moves = currentGameState.generateMoves(clickedLoc);
		for (const Move& m : moves)
		{
			GameBoardButton* targetButton = boardButtons[m.to.y][m.to.x];
			targetButton->setStyleSheet("background-color:green;");
			highlightedButtons.push_back(targetButton);
		}
	}
	else if (selectedButton && currentGameState.canMove(BoardLocation(selectedButton->column, selectedButton->row), clickedLoc, currentPlayer))
	{
		// revert all currently highlighted buttons back to their normal color
		for (GameBoardButton* highlighted : highlightedButtons)
		{
			highlighted->resetBackgroundColor();
		}
		highlightedButtons.clear();

		// generate the move we're playing
		bool capture = (occupier == currentGameState.getOpponentColor(currentPlayer));
		Move move(BoardLocation(selectedButton->column, selectedButton->row), clickedLoc, capture);

		// apply the move and update GUI status
		currentGameState.applyMove(move);
		currentGameState.switchCurrentPlayer();

		updateGui();
		selectedButton->setStyleSheet("background-color:blue;");	// make the square we came from blue
		highlightedButtons.push_back(selectedButton);
		selectedButton = nullptr;
	}
}

void SerPrunesALotWindow::initBoard()
{
	currentGameState.reset();
}

void SerPrunesALotWindow::resizeEvent(QResizeEvent* event)
{
	QMainWindow::resizeEvent(event);

	updateGui();
}

void SerPrunesALotWindow::updateGui()
{
	for (int y = 0; y < BOARD_HEIGHT; ++y)
	{
		for (int x = 0; x < BOARD_WIDTH; ++x)
		{
			EPlayerColors::Type occupant = currentGameState.getOccupier(BoardLocation(x, y));
			GameBoardButton* button = boardButtons[y][x];

			if (occupant == EPlayerColors::NOTHING)
			{
				button->setIcon(QIcon());
			}
			else if (occupant == EPlayerColors::BLACK_PLAYER)
			{
				button->setIcon(QIcon(":/Resources/Resources/BlackIcon.png"));
				button->setIconSize(0.75f * button->size());
			}
			else if (occupant == EPlayerColors::WHITE_PLAYER)
			{
				button->setIcon(QIcon(":/Resources/Resources/WhiteIcon.png"));
				button->setIconSize(0.75f * button->size());
			}
		}
	}
}